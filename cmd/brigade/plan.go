package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/spf13/cobra"

	"brigade/internal/config"
	"brigade/internal/prd"
	"brigade/internal/state"
	"brigade/internal/util"
	"brigade/internal/worker"
)

var planCmd = &cobra.Command{
	Use:   "plan <description>",
	Short: "Generate a PRD from a feature description",
	Long: `Invokes Executive Chef to analyze the codebase and generate a PRD.

Example:
  ./brigade-go plan "Add user authentication with JWT"`,
	Args: cobra.MinimumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load(cfgFile)
		if err != nil {
			return fmt.Errorf("loading config: %w", err)
		}
		description := strings.Join(args, " ")
		return cmdPlan(description, cfg)
	},
}

func cmdPlan(description string, cfg *config.Config) error {
	// Create tasks directory if it doesn't exist
	if err := os.MkdirAll("brigade/tasks", 0755); err != nil {
		return err
	}

	// Generate filename from description
	slug := util.Slugify(description, 50)
	prdPath := fmt.Sprintf("brigade/tasks/prd-%s.json", slug)
	today := time.Now().Format("2006-01-02")

	fmt.Println()
	fmt.Printf("%s═══════════════════════════════════════════════════════════%s\n", colorCyan, colorReset)
	fmt.Printf("PLANNING PHASE: %s\n", description)
	fmt.Printf("%s═══════════════════════════════════════════════════════════%s\n\n", colorCyan, colorReset)

	// Build planning prompt
	var promptBuilder strings.Builder

	// Read skill file if available
	skillFiles := []string{
		"brigade/commands/brigade-generate-prd.md",
		"brigade/.claude/skills/generate-prd.md",
	}
	for _, sf := range skillFiles {
		if content, err := os.ReadFile(sf); err == nil {
			promptBuilder.Write(content)
			promptBuilder.WriteString("\n\n---\n")
			break
		}
	}

	// Check for codebase map staleness and include if available
	if mapStaleness := checkMapStaleness("brigade/codebase-map.md"); mapStaleness == 2 {
		// No map exists
		fmt.Printf("%sTip: Run './brigade.sh map' to generate a codebase map for better planning context.%s\n\n", colorDim, colorReset)
	} else if mapStaleness == 1 {
		// Map is stale - regenerate
		fmt.Printf("%sCodebase map is stale. Consider regenerating with './brigade.sh map'%s\n\n", colorYellow, colorReset)
	}

	if content, err := os.ReadFile("brigade/codebase-map.md"); err == nil {
		promptBuilder.WriteString("\n---\nCODEBASE MAP (generated by ./brigade.sh map):\n")
		promptBuilder.Write(content)
		promptBuilder.WriteString("\n---\n")
	}

	// Add planning request
	promptBuilder.WriteString(fmt.Sprintf(`PLANNING REQUEST

Feature Description: %s
Output File: %s
Today's Date: %s

INSTRUCTIONS:
1. Analyze the codebase to understand project structure and patterns
2. Break down the feature into well-scoped tasks
3. Assign appropriate complexity (junior/senior) to each task
4. Define dependencies between tasks
5. Write specific, verifiable acceptance criteria

OUTPUT:
Generate the PRD JSON and save it to: %s

After generating, output:
<prd_generated>%s</prd_generated>

BEGIN PLANNING:`, description, prdPath, today, prdPath, prdPath))

	prompt := promptBuilder.String()

	fmt.Printf("%sInvoking Executive Chef (Director)...%s\n", colorDim, colorReset)
	fmt.Printf("%sRunning in quick mode (no interview). For full interview, use /brigade-generate-prd in Claude Code.%s\n\n", colorDim, colorReset)

	start := time.Now()

	// Create worker for Executive Chef
	workerCfg := &worker.Config{
		Command:    cfg.ExecutiveCmd,
		Tier:       state.TierExecutive,
		Timeout:    cfg.TaskTimeoutExecutive,
		WorkingDir: "",
		Quiet:      false, // Show output
	}
	exec := worker.NewCLIWorker(workerCfg)

	// Execute
	result, err := exec.Execute(context.Background(), prompt)
	if err != nil {
		return fmt.Errorf("executing plan: %w", err)
	}

	duration := time.Since(start)
	fmt.Printf("\n%sDuration: %ds%s\n", colorDim, int(duration.Seconds()), colorReset)

	// Check if PRD was generated
	generatedPath := ""

	// Try to extract from signal
	if result.Output != "" {
		re := regexp.MustCompile(`<prd_generated>([^<]+)</prd_generated>`)
		if matches := re.FindStringSubmatch(result.Output); len(matches) > 1 {
			generatedPath = strings.TrimSpace(matches[1])
		}
	}

	// Fall back to checking if file exists
	if generatedPath == "" {
		if _, err := os.Stat(prdPath); err == nil {
			generatedPath = prdPath
		}
	}

	if generatedPath != "" && fileExists(generatedPath) {
		// Update latest symlink
		updateLatestSymlink(generatedPath)

		fmt.Println()
		fmt.Printf("%s╔═══════════════════════════════════════════════════════════╗%s\n", colorGreen, colorReset)
		fmt.Printf("%s║  PRD GENERATED: %s%s\n", colorGreen, generatedPath, colorReset)
		fmt.Printf("%s╚═══════════════════════════════════════════════════════════╝%s\n\n", colorGreen, colorReset)

		// Show summary
		if p, err := prd.Load(generatedPath); err == nil {
			juniorCount := 0
			seniorCount := 0
			for _, task := range p.Tasks {
				if task.Complexity == prd.ComplexitySenior {
					seniorCount++
				} else {
					juniorCount++
				}
			}
			fmt.Printf("Tasks: %d total (%s%d senior%s, %s%d junior%s)\n\n",
				len(p.Tasks), colorCyan, seniorCount, colorReset, colorGreen, juniorCount, colorReset)
		}

		fmt.Printf("%sNext steps:%s\n", colorBold, colorReset)
		fmt.Printf("  1. Review the PRD: %scat %s | jq%s\n", colorCyan, generatedPath, colorReset)
		fmt.Printf("  2. Run service:    %s./brigade.sh service %s%s\n", colorCyan, generatedPath, colorReset)
	} else {
		fmt.Println()
		fmt.Printf("%sPRD generation may have failed. Check output above.%s\n", colorYellow, colorReset)
	}

	return nil
}

// checkMapStaleness checks if the codebase map exists and is up-to-date.
// Returns: 0 = fresh, 1 = stale, 2 = not found
func checkMapStaleness(mapPath string) int {
	content, err := os.ReadFile(mapPath)
	if err != nil {
		return 2 // Not found
	}

	// Extract commit hash from map
	re := regexp.MustCompile(`<!-- Generated at commit: ([a-f0-9]+) -->`)
	matches := re.FindSubmatch(content)
	if len(matches) < 2 {
		return 1 // No commit tracking = stale (old format)
	}

	mapCommit := string(matches[1])
	headCommit := util.GetHeadCommit()

	if mapCommit == headCommit {
		return 0 // Fresh
	}

	return 1 // Stale
}

func updateLatestSymlink(prdPath string) {
	symlink := "brigade/tasks/prd-latest.json"
	os.Remove(symlink) // Remove existing symlink if any

	// Get relative path from symlink location to target
	relPath, err := filepath.Rel(filepath.Dir(symlink), prdPath)
	if err != nil {
		return
	}

	os.Symlink(relPath, symlink)
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
